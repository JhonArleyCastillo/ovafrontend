/**
 * üîå WebSocket Manager - Gestor Robusto de Conexiones WebSocket
 * 
 * Este archivo es el CORAZ√ìN de las comunicaciones en tiempo real de la aplicaci√≥n.
 * Como desarrollador fullstack, aqu√≠ es donde manejamos todos los aspectos complejos
 * de las conexiones WebSocket, desde la detecci√≥n autom√°tica de servidores hasta
 * la reconexi√≥n inteligente cuando la conexi√≥n se pierde.
 * 
 * üéØ ¬øQU√â HACE ESTE ARCHIVO?
 * - Maneja conexiones WebSocket robustas con el backend FastAPI
 * - Implementa retry autom√°tico con backoff exponencial
 * - Detecta autom√°ticamente si el servidor est√° disponible
 * - Configura diferentes endpoints seg√∫n el entorno (dev/staging/prod)
 * - Mantiene heartbeats para detectar conexiones muertas
 * - Rota entre m√∫ltiples URLs si una falla
 * 
 * üîó CONEXI√ìN CON EL BACKEND:
 * Este manager se conecta al endpoint '/api/chat' del FastAPI backend.
 * El backend maneja estas conexiones en websocket_routes.py usando el
 * WebSocketConnectionManager que ya humanizamos.
 * 
 * üí° TIP PARA DEBUGGING:
 * Si los mensajes no llegan, revisa:
 * 1. Los logs del navegador (este archivo loggea todo)
 * 2. El estado de la conexi√≥n con getConnectionState()
 * 3. Que el backend est√© ejecut√°ndose en el puerto correcto
 * 4. Los CORS en el backend si hay problemas de origen cruzado
 * 
 * üõ†Ô∏è CONFIGURACI√ìN POR ENTORNOS:
 * - Development: localhost:8000
 * - Staging: staging-api.ovaonline.tech  
 * - Production: api.ovaonline.tech
 * 
 * Incluye retry autom√°tico, detecci√≥n de servidor y configuraci√≥n por entornos
 */

import Logger from '../utils/debug-utils';

// üîß CONFIGURACI√ìN MAESTRA√Å DEL WEBSOCKET
// Esta configuraci√≥n controla todos los aspectos del comportamiento WebSocket.
// Como desarrollador, aqu√≠ es donde ajustas timeouts, reintentos, y URLs.

// ‚è±Ô∏è Tiempos de espera cr√≠ticos
export const WS_CONFIG = {
  // Tiempos de espera (ajustables seg√∫n la latencia de tu servidor)
  CONNECTION_TIMEOUT: 10000, // 10 segundos - si el servidor tarda m√°s, hay un problema
  HEARTBEAT_INTERVAL: 30000, // 30 segundos - ping/pong para mantener viva la conexi√≥n
  
  // üîÑ Configuraci√≥n de retry inteligente
  // Estos valores implementan backoff exponencial para no sobrecargar el servidor
  MAX_RETRY_ATTEMPTS: 5,      // M√°ximo 5 intentos antes de rendirse
  INITIAL_RETRY_DELAY: 1000,  // Empieza con 1 segundo
  MAX_RETRY_DELAY: 30000,     // Nunca esperes m√°s de 30 segundos
  RETRY_BACKOFF_FACTOR: 2,    // Duplica el tiempo en cada intento: 1s, 2s, 4s, 8s, 16s
  
  // üö¶ Estados de conexi√≥n (√∫tiles para mostrar indicators en la UI)
  CONNECTION_STATES: {
    CONNECTING: 'connecting',     // Mostrando spinner
    CONNECTED: 'connected',       // Todo OK, icono verde
    DISCONNECTED: 'disconnected', // Desconectado, icono gris
    RECONNECTING: 'reconnecting', // Reintentando, icono amarillo
    FAILED: 'failed'             // Error fatal, icono rojo
  },
  
  // üìã C√≥digos de cierre est√°ndar WebSocket RFC 6455
  // √ötiles para debugging: cada c√≥digo te dice exactamente qu√© pas√≥
  CLOSE_CODES: {
    NORMAL: 1000,                    // Cierre normal - todo OK
    GOING_AWAY: 1001,               // Usuario cerr√≥ la pesta√±a/navegador
    PROTOCOL_ERROR: 1002,           // Error de protocolo WebSocket
    UNSUPPORTED_DATA: 1003,         // Datos no soportados
    ABNORMAL_CLOSURE: 1006,         // Conexi√≥n perdida sin close frame
    INVALID_FRAME_PAYLOAD_DATA: 1007, // Datos corruptos
    POLICY_VIOLATION: 1008,         // Violaci√≥n de pol√≠tica (CORS, etc.)
    MESSAGE_TOO_BIG: 1009,         // Mensaje demasiado grande
    MISSING_EXTENSION: 1010,        // Extensi√≥n requerida no presente
    INTERNAL_ERROR: 1011,          // Error interno del servidor
    SERVICE_RESTART: 1012,         // Servidor reinici√°ndose
    TRY_AGAIN_LATER: 1013,        // Servidor sobrecargado
    BAD_GATEWAY: 1014,            // Gateway malo
    TLS_HANDSHAKE: 1015           // Error SSL/TLS
  },
  
  // üåê URLs por entorno - AQU√ç CONFIGURAS TUS SERVIDORES
  // Como desarrollador fullstack, aqu√≠ mapeas frontend a backend
  ENDPOINTS: {
    development: {
      primary: 'ws://localhost:8000/api/chat',    // Tu servidor local FastAPI
      fallback: 'ws://127.0.0.1:8000/api/chat'   // IP en caso de problemas DNS
    },
    staging: {
      primary: 'wss://staging-api.ovaonline.tech/api/chat',  // Servidor de pruebas
      fallback: 'wss://staging.ovaonline.tech/api/chat'      // Backup staging
    },
    production: {
      primary: 'wss://www.api.ovaonline.tech/api/chat',      // Servidor producci√≥n
      fallback: 'wss://www.api.ovaonline.tech/ws/chat'       // Ruta alternativa prod
    }
  }
};

/**
 * üéØ WebSocketManager - Clase Principal de Gesti√≥n WebSocket
 * 
 * Esta clase es tu mejor amiga para manejar conexiones WebSocket complejas.
 * Encapsula toda la l√≥gica de conexi√≥n, reconexi√≥n, heartbeats, y manejo de errores
 * que normalmente tendr√≠as que implementar una y otra vez.
 * 
 * üíº ¬øC√ìMO LA USAS?
 * ```javascript
 * const wsManager = new WebSocketManager('ChatComponent');
 * await wsManager.connect({
 *   onMessage: (event) => console.log('Mensaje:', event.data),
 *   onOpen: () => console.log('¬°Conectado!'),
 *   onClose: () => console.log('Desconectado'),
 *   onError: (error) => console.error('Error:', error)
 * });
 * ```
 * 
 * üîÑ GESTI√ìN AUTOM√ÅTICA:
 * - Detecta autom√°ticamente el entorno (dev/staging/prod)
 * - Rota entre URLs si una falla
 * - Implementa backoff exponencial para reintentos
 * - Mantiene heartbeats autom√°ticos
 * - Limpia recursos autom√°ticamente
 */
export class WebSocketManager {
  constructor(componentName = 'WebSocketManager') {
    // üè∑Ô∏è Identificaci√≥n para logs (√∫til cuando tienes m√∫ltiples instances)
    this.componentName = componentName;
    
    // üîå Estado de la conexi√≥n WebSocket
    this.ws = null;                    // Instancia actual del WebSocket
    this.currentUrl = null;            // URL a la que estamos conectados
    this.retryCount = 0;              // Contador de reintentos actuales
    this.retryTimer = null;           // Timer para programar reintentos
    this.heartbeatTimer = null;       // Timer para heartbeats peri√≥dicos
    this.connectionState = WS_CONFIG.CONNECTION_STATES.DISCONNECTED;
    this.handlers = {};               // Callbacks personalizados del usuario
    this.shouldReconnect = true;      // Flag para controlar reconexi√≥n autom√°tica
    this.connectionTimeout = null;     // Timer para timeout de conexi√≥n inicial
    
    // üåç Detecci√≥n autom√°tica de entorno
    // NODE_ENV viene del build de React, determina qu√© URLs usar
    const env = process.env.NODE_ENV || 'development';
    this.endpoints = WS_CONFIG.ENDPOINTS[env] || WS_CONFIG.ENDPOINTS.development;
    
    Logger.debug(this.componentName, `üöÄ WebSocket Manager inicializado para entorno: ${env}`);
    Logger.debug(this.componentName, `üéØ URLs disponibles: ${JSON.stringify(this.endpoints)}`);
  }

  /**
   * üè• Verificaci√≥n de Salud del Servidor
   * 
   * Antes de intentar una conexi√≥n WebSocket, verificamos si el servidor HTTP
   * est√° respondiendo. Esto evita timeouts largos y proporciona feedback r√°pido.
   * 
   * üîç ESTRATEGIA DE VERIFICACI√ìN:
   * 1. Intenta /chat/health (endpoint espec√≠fico para WebSocket)
   * 2. Si falla, intenta /api/chat/health (ruta alternativa)
   * 3. Como √∫ltimo recurso, intenta /status (endpoint general)
   * 
   * üí° TIP: Si constantemente falla aqu√≠, revisa:
   * - Que el backend FastAPI est√© ejecut√°ndose
   * - Que los endpoints de health est√©n implementados
   * - La configuraci√≥n de CORS en el backend
   * 
   * @param {string} wsUrl - URL del WebSocket (convertimos a HTTP para verificar)
   * @returns {Promise<boolean>} - true si el servidor responde
   */
  async checkServerAvailability(wsUrl) {
    try {
      // üîÑ Conversi√≥n inteligente: WebSocket URL ‚Üí HTTP URL
      // ws://localhost:8000/api/chat ‚Üí http://localhost:8000
      // wss://api.example.com/api/chat ‚Üí https://api.example.com
      const parsed = new URL(wsUrl);
      const httpProto = parsed.protocol === 'wss:' ? 'https:' : 'http:';
      const origin = `${httpProto}//${parsed.host}`;
      
      // üéØ Endpoints a verificar en orden de prioridad
      const healthUrl = `${origin}/chat/health`;      // Espec√≠fico para chat
      const apiHealthUrl = `${origin}/api/chat/health`; // Alternativa API
      const statusUrl = `${origin}/status`;            // Fallback general
      
      // üöÄ Primer intento: endpoint espec√≠fico de WebSocket
      Logger.debug(this.componentName, `üîç Verificando salud del servidor: ${healthUrl}`);
      
      // ‚è∞ Control de timeout para evitar esperas eternas
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 segundos m√°ximo
      
      const response = await fetch(healthUrl, {
        method: 'GET',
        signal: controller.signal,    // Para cancelar si tarda mucho
        cache: 'no-cache'            // Siempre verificar estado actual
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        Logger.debug(this.componentName, `‚úÖ Servidor WebSocket disponible en ${healthUrl}`);
        return true;
      } else {
        // üîÑ Estrategia de fallback: probar endpoints alternativos
        Logger.warn(this.componentName, `‚ö†Ô∏è WS health respondi√≥ ${response.status}. Probando ${apiHealthUrl}`);
        
        const resApi = await fetch(apiHealthUrl, { method: 'GET', cache: 'no-cache' });
        if (resApi.ok) {
          Logger.debug(this.componentName, `‚úÖ Servidor disponible en ruta alternativa: ${apiHealthUrl}`);
          return true;
        }
        
        Logger.warn(this.componentName, `‚ö†Ô∏è API health respondi√≥ ${resApi.status}. Probando fallback: ${statusUrl}`);
        const res2 = await fetch(statusUrl, { method: 'GET', cache: 'no-cache' });
        if (res2.ok) {
          Logger.debug(this.componentName, `‚úÖ Servidor HTTP disponible (fallback): ${statusUrl}`);
          return true;
        }
        
        Logger.error(this.componentName, '‚ùå Ning√∫n endpoint responde. Servidor probablemente offline.');
        return false;
      }
    } catch (error) {
      // üí• Captura errores de red, CORS, timeouts, etc.
      Logger.warn(this.componentName, `üö´ Error verificando servidor: ${error.message}`);
      return false;
    }
  }

  /**
   * üìà C√°lculo de Delay con Backoff Exponencial
   * 
   * Implementa la estrategia "exponential backoff with jitter" que es el est√°ndar
   * en sistemas distribuidos para evitar el "thundering herd problem".
   * 
   * üßÆ F√ìRMULA: 
   * delay = min(INITIAL_DELAY * (BACKOFF_FACTOR ^ attempt), MAX_DELAY) + jitter
   * 
   * üìä EJEMPLO CON VALORES ACTUALES:
   * Intento 1: 1s + jitter
   * Intento 2: 2s + jitter  
   * Intento 3: 4s + jitter
   * Intento 4: 8s + jitter
   * Intento 5: 16s + jitter
   * 
   * üé≤ JITTER: A√±ade aleatoriedad para evitar que m√∫ltiples clientes
   * reconecten exactamente al mismo tiempo y saturen el servidor.
   * 
   * @param {number} attempt - N√∫mero de intento actual (0-based)
   * @returns {number} Delay en milisegundos antes del pr√≥ximo intento
   */
  calculateRetryDelay(attempt) {
    // üìà Backoff exponencial: cada intento espera el doble que el anterior
    const delay = Math.min(
      WS_CONFIG.INITIAL_RETRY_DELAY * Math.pow(WS_CONFIG.RETRY_BACKOFF_FACTOR, attempt),
      WS_CONFIG.MAX_RETRY_DELAY
    );
    
    // üé≤ Jitter: a√±adimos hasta 10% de variaci√≥n aleatoria
    // Esto distribuye las reconexiones en el tiempo y evita sobrecargar el servidor
    const jitter = Math.random() * 0.1 * delay;
    const finalDelay = Math.floor(delay + jitter);
    
    Logger.debug(this.componentName, `‚è±Ô∏è Delay calculado para intento ${attempt}: ${finalDelay}ms`);
    return finalDelay;
  }

  /**
   * üöÄ M√©todo Principal de Conexi√≥n
   * 
   * Este es el m√©todo que llamas desde tus componentes React para establecer
   * una conexi√≥n WebSocket. Guarda los handlers y delega a attemptConnection().
   * 
   * üí° USO T√çPICO:
   * ```javascript
   * const wsManager = new WebSocketManager('ChatComponent');
   * await wsManager.connect({
   *   onOpen: () => setConnectionStatus('connected'),
   *   onMessage: handleIncomingMessage,
   *   onClose: () => setConnectionStatus('disconnected'),
   *   onError: handleConnectionError
   * });
   * ```
   * 
   * @param {Object} handlers - Objeto con callbacks para eventos WebSocket
   * @param {Function} handlers.onOpen - Llamado cuando se establece conexi√≥n
   * @param {Function} handlers.onMessage - Llamado cuando llega un mensaje
   * @param {Function} handlers.onClose - Llamado cuando se cierra conexi√≥n
   * @param {Function} handlers.onError - Llamado cuando hay un error
   * @returns {Promise<WebSocket>} - Promesa que resuelve con el WebSocket conectado
   */
  async connect(handlers = {}) {
    Logger.debug(this.componentName, `üéØ Iniciando proceso de conexi√≥n con handlers: ${Object.keys(handlers).join(', ')}`);
    
    this.handlers = handlers;          // Guardamos handlers para reconexiones autom√°ticas
    this.shouldReconnect = true;       // Habilitamos reconexi√≥n autom√°tica
    
    return this.attemptConnection();
  }

  /**
   * üîÑ Motor de Intentos de Conexi√≥n
   * 
   * Esta es la l√≥gicaÊ†∏ÂøÉ que maneja toda la complejidad de conectar:
   * - Rotaci√≥n inteligente entre URLs disponibles
   * - Verificaci√≥n de salud del servidor antes de conectar
   * - Manejo de timeouts y cleanup autom√°tico
   * - Configuraci√≥n de event listeners
   * 
   * üéØ ESTRATEGIA DE ROTACI√ìN DE URLs:
   * 1. Genera todas las variantes posibles (/api/chat y /ws/chat)
   * 2. Elimina duplicados manteniendo el orden
   * 3. Rota por intento: intento 0 = URL primaria, intento 1 = fallback, etc.
   * 
   * üí° TIP: Si siempre falla en el primer intento pero funciona en reintentos,
   * probablemente el servidor tarda en inicializar. Considera aumentar
   * CONNECTION_TIMEOUT o agregar un health check m√°s robusto.
   * 
   * @param {boolean} isRetry - true si es un reintento autom√°tico
   * @returns {Promise<WebSocket>} - WebSocket conectado o null si falla
   */
  async attemptConnection(isRetry = false) {
    // üõë Verificaci√≥n de seguridad: ¬øel usuario cancel√≥ la conexi√≥n?
    if (!this.shouldReconnect) {
      Logger.debug(this.componentName, 'üö´ Conexi√≥n cancelada por usuario o deshabilitada');
      return null;
    }

    // üîÄ Generaci√≥n inteligente de candidatos de conexi√≥n
    // Tomamos las URLs base y generamos variantes con diferentes rutas
    const base = [this.endpoints.primary, this.endpoints.fallback];
    const variants = base.flatMap(u => {
      // Si la URL contiene /api/chat, tambi√©n probamos /ws/chat
      if (u.includes('/api/chat')) return [u, u.replace('/api/chat', '/ws/chat')];
      // Si contiene /ws/chat, tambi√©n probamos /api/chat  
      if (u.includes('/ws/chat')) return [u, u.replace('/ws/chat', '/api/chat')];
      // Si no tiene ninguna, la devolvemos tal como est√°
      return [u];
    });
    
    // üîÑ Eliminamos duplicados pero preservamos el orden (Set mantiene insertion order)
    const candidates = Array.from(new Set(variants));
    
    // üìç Selecci√≥n de URL por rotaci√≥n: usamos el retryCount como √≠ndice
    // Intento 0: candidates[0], Intento 1: candidates[1], etc.
    // Si hay m√°s intentos que candidatos, usamos el √∫ltimo
    const index = Math.min(this.retryCount, candidates.length - 1);
    const url = candidates[index];
    this.currentUrl = url;
    
    // üìä Logging diferenciado para conexiones iniciales vs reintentos
    if (isRetry) {
      this.connectionState = WS_CONFIG.CONNECTION_STATES.RECONNECTING;
      Logger.debug(this.componentName, `üîÑ Reintentando conexi√≥n (${this.retryCount}/${WS_CONFIG.MAX_RETRY_ATTEMPTS}) a ${url}`);
    } else {
      this.connectionState = WS_CONFIG.CONNECTION_STATES.CONNECTING;
      Logger.debug(this.componentName, `üöÄ Iniciando conexi√≥n inicial a ${url}`);
    }

    // üè• Verificaci√≥n proactiva de salud del servidor
    // Solo en los primeros intentos - despu√©s asumimos que el problema es temporal
    const isServerAvailable = await this.checkServerAvailability(url);
    if (!isServerAvailable && this.retryCount < 2) {
      Logger.warn(this.componentName, `üö´ Servidor no disponible en ${url}. Programando reintento...`);
      this.scheduleRetry();
      return null;
    }

    try {
      // üßπ Limpieza preventiva: eliminar cualquier conexi√≥n anterior
      this.cleanup();
      
      // üîå Creaci√≥n de la nueva conexi√≥n WebSocket
      Logger.debug(this.componentName, `üîó Creando WebSocket hacia ${url}...`);
      this.ws = new WebSocket(url);
      
      // ‚è∞ Configuraci√≥n de timeout de conexi√≥n
      // Si el WebSocket se queda en estado CONNECTING m√°s de X segundos, algo est√° mal
      this.connectionTimeout = setTimeout(() => {
        if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
          Logger.warn(this.componentName, `‚è∞ Timeout de conexi√≥n WebSocket (${WS_CONFIG.CONNECTION_TIMEOUT}ms)`);
          this.ws.close();
          this.scheduleRetry();
        }
      }, WS_CONFIG.CONNECTION_TIMEOUT);

      // üéØ Configuraci√≥n de todos los event listeners
      this.setupEventListeners();
      
      // üìû Devolvemos una Promise que resuelve cuando se abre la conexi√≥n
      return new Promise((resolve, reject) => {
        // ‚úÖ √âxito: conexi√≥n establecida
        this.ws.addEventListener('open', () => {
          Logger.debug(this.componentName, 'üéâ Conexi√≥n WebSocket exitosa!');
          resolve(this.ws);
        }, { once: true });
        
        // ‚ùå Error: fallo en la conexi√≥n
        this.ws.addEventListener('error', (error) => {
          Logger.error(this.componentName, 'üí• Error en conexi√≥n WebSocket:', error);
          reject(new Error('Error en conexi√≥n WebSocket'));
        }, { once: true });
      });
      
    } catch (error) {
      // üö® Captura errores s√≠ncronos (ej: URL malformada)
      Logger.error(this.componentName, `üí• Error creando WebSocket: ${error.message}`, error);
      this.scheduleRetry();
      return null;
    }
  }

  /**
   * üéõÔ∏è Configuraci√≥n de Event Listeners
   * 
   * Aqu√≠ es donde "cableamos" todos los eventos del WebSocket a nuestros
   * m√©todos internos. Es importante no establecer los listeners directamente
   * en el constructor porque podr√≠amos tener memory leaks.
   * 
   * üîó CONEXI√ìN DE EVENTOS:
   * - onopen ‚Üí onConnectionOpen (maneja √©xito de conexi√≥n)
   * - onmessage ‚Üí onMessage (procesa mensajes entrantes)
   * - onclose ‚Üí onConnectionClose (maneja desconexiones)
   * - onerror ‚Üí onConnectionError (maneja errores)
   */
  setupEventListeners() {
    if (!this.ws) {
      Logger.warn(this.componentName, '‚ö†Ô∏è No se puede configurar listeners: WebSocket no existe');
      return;
    }

    // üîó Asignaci√≥n de handlers internos
    this.ws.onopen = (event) => {
      this.onConnectionOpen(event);
    };

    this.ws.onmessage = (event) => {
      this.onMessage(event);
    };

    this.ws.onclose = (event) => {
      this.onConnectionClose(event);
    };

    this.ws.onerror = (event) => {
      this.onConnectionError(event);
    };
    
    Logger.debug(this.componentName, 'üéõÔ∏è Event listeners configurados exitosamente');
  }

  /**
   * üéâ Handler de Conexi√≥n Exitosa
   * 
   * ¬°√âxito! El WebSocket se conect√≥ correctamente. Aqu√≠ es donde:
   * - Reseteamos contadores y timers
   * - Iniciamos el sistema de heartbeat
   * - Notificamos al componente React que estamos conectados
   * 
   * üí° NOTA: Este m√©todo se llamar√° tanto en conexiones iniciales como
   * en reconexiones autom√°ticas. Tu componente React deber√≠a manejar
   * ambos casos de manera id√©ntica.
   */
  onConnectionOpen(event) {
    // üìù Log de √©xito (reducido a debug para minimizar ruido en consola)
    Logger.debug(this.componentName, `‚úÖ WebSocket conectado exitosamente a ${this.currentUrl}`);
    
    // üßπ Limpieza de timers y reset de estado
    this.clearTimers();                 // Cancelar timeouts pendientes
    this.retryCount = 0;               // Resetear contador de reintentos
    this.connectionState = WS_CONFIG.CONNECTION_STATES.CONNECTED;
    
    // üíì Iniciar sistema de heartbeat para mantener viva la conexi√≥n
    this.startHeartbeat();
    
    // üì¢ Notificar al componente React que estamos conectados
    if (this.handlers.onOpen) {
      try {
        this.handlers.onOpen(event);
      } catch (error) {
        Logger.error(this.componentName, 'üí• Error en handler onOpen personalizado:', error);
      }
    }
  }

  /**
   * üì® Handler de Mensajes Entrantes
   * 
   * Cada vez que el servidor nos env√≠a algo, este m√©todo se ejecuta.
   * Aqu√≠ solo hacemos logging y delegamos al handler personalizado del componente.
   * 
   * üí° TIPOS DE MENSAJES COMUNES:
   * - Mensajes de chat del usuario
   * - Respuestas de procesamiento ASL
   * - Pings/pongs del heartbeat
   * - Notificaciones de estado del servidor
   * 
   * üîç DEBUGGING: Si no recibes mensajes, verifica:
   * 1. Que el handler onMessage est√© configurado
   * 2. Que el backend est√© enviando a la conexi√≥n correcta
   * 3. El formato del mensaje (debe ser texto v√°lido o JSON)
   */
  onMessage(event) {
    // üìä Log truncado para no llenar la consola con mensajes largos
    const preview = event.data?.substring(0, 100) || '[mensaje vac√≠o]';
    Logger.debug(this.componentName, `üì® Mensaje recibido: ${preview}${event.data?.length > 100 ? '...' : ''}`);
    
    // üì¢ Delegar al handler personalizado del componente
    if (this.handlers.onMessage) {
      try {
        this.handlers.onMessage(event);
      } catch (error) {
        Logger.error(this.componentName, 'üí• Error en handler onMessage personalizado:', error);
      }
    } else {
      Logger.warn(this.componentName, '‚ö†Ô∏è Mensaje recibido pero no hay handler onMessage configurado');
    }
  }

  /**
   * üîå Handler de Cierre de Conexi√≥n
   * 
   * Cuando la conexi√≥n WebSocket se cierra, necesitamos entender POR QU√â
   * se cerr√≥ para decidir si debemos reconectar autom√°ticamente o no.
   * 
   * üîç C√ìDIGOS DE CIERRE IMPORTANTES:
   * - 1000: Cierre normal (usuario cerr√≥ pesta√±a, etc.) - NO reconectar
   * - 1006: Cierre anormal (red, servidor ca√≠do) - S√ç reconectar  
   * - 1011: Error interno del servidor - S√ç reconectar
   * - 1012: Servidor reinici√°ndose - S√ç reconectar
   * 
   * üí° ESTRATEGIA DE RECONEXI√ìN:
   * - Solo reconectamos si shouldReconnect = true
   * - No reconectamos en cierres normales (c√≥digo 1000)
   * - Limitamos a MAX_RETRY_ATTEMPTS intentos
   */
  onConnectionClose(event) {
    // üìä Informaci√≥n detallada del cierre para debugging
    const closeInfo = {
      code: event.code,
      reason: event.reason || 'Sin raz√≥n especificada',
      wasClean: event.wasClean     // true = cierre controlado, false = abrupto
    };
    
    Logger.warn(this.componentName, `üîå WebSocket cerrado: ${JSON.stringify(closeInfo)}`);
    
    // üìä Actualizar estado interno
    this.connectionState = WS_CONFIG.CONNECTION_STATES.DISCONNECTED;
    this.clearTimers();    // Limpiar heartbeats y timeouts
    
    // ü§î ¬øDebemos reconectar autom√°ticamente?
    const shouldRetry = this.shouldReconnect &&                           // Reconexi√≥n habilitada
                       event.code !== WS_CONFIG.CLOSE_CODES.NORMAL &&     // No fue cierre normal
                       this.retryCount < WS_CONFIG.MAX_RETRY_ATTEMPTS;     // No hemos agotado intentos
    
    if (shouldRetry) {
      Logger.debug(this.componentName, 'üîÑ Programando reconexi√≥n autom√°tica...');
      this.scheduleRetry();
    } else if (this.retryCount >= WS_CONFIG.MAX_RETRY_ATTEMPTS) {
      // üíÄ Hemos agotado todos los intentos - marcar como fallido
      this.connectionState = WS_CONFIG.CONNECTION_STATES.FAILED;
  Logger.error(this.componentName, `‚ùå M√°ximo n√∫mero de reintentos alcanzado (${WS_CONFIG.MAX_RETRY_ATTEMPTS}). Conexi√≥n marcada como fallida.`);
    } else {
      // ‚úã Cierre normal o reconexi√≥n deshabilitada
  Logger.debug(this.componentName, `‚úã No se reintentar√° conexi√≥n: c√≥digo=${event.code}, shouldReconnect=${this.shouldReconnect}`);
    }
    
    // üì¢ Notificar al componente React del cierre
    if (this.handlers.onClose) {
      try {
        this.handlers.onClose(event);
      } catch (error) {
        Logger.error(this.componentName, 'üí• Error en handler onClose personalizado:', error);
      }
    }
  }

  /**
   * ‚ùå Handler de Errores de Conexi√≥n
   * 
   * Este handler se ejecuta cuando hay errores durante la conexi√≥n o
   * transmisi√≥n de datos. Es importante NO manejar reconexi√≥n aqu√≠
   * porque onClose siempre se ejecuta despu√©s de onError.
   * 
   * üö® ERRORES COMUNES:
   * - Error de red (sin internet, servidor ca√≠do)
   * - Error de protocolo (datos corruptos)
   * - Error de autenticaci√≥n (tokens inv√°lidos)
   * - Error de CORS (dominios no permitidos)
   * 
   * üí° DEBUGGING: Los errores WebSocket son notoriamente poco informativos.
   * Si hay problemas, tambi√©n revisa:
   * - Network tab del DevTools
   * - Logs del servidor backend
   * - Configuraci√≥n de proxy/firewall
   */
  onConnectionError(event) {
    Logger.error(this.componentName, `‚ùå Error en WebSocket ${this.currentUrl}:`, event);
    
    // üö´ NO programar retry aqu√≠ - se har√° en onClose que siempre se ejecuta despu√©s
    // onError ‚Üí onClose es la secuencia normal de eventos
    
    // üì¢ Notificar al componente React del error
    if (this.handlers.onError) {
      try {
        this.handlers.onError(event);
      } catch (error) {
        Logger.error(this.componentName, 'üí• Error en handler onError personalizado:', error);
      }
    }
  }

  /**
   * ‚è∞ Programador de Reintentos
   * Cuando una conexi√≥n falla, este m√©todo programa el pr√≥ximo intento
   * usando backoff exponencial para no sobrecargar el servidor.
   * 
   * üîÑ FLUJO DE RECONEXI√ìN:
   * 1. Incrementa retryCount
   * 2. Calcula delay con backoff exponencial + jitter
   * 3. Programa timer para llamar attemptConnection(true)
   * 4. Si se agotaron intentos, no hace nada
   * 
   * üõ°Ô∏è PROTECCIONES:
   * - Verifica shouldReconnect (usuario puede deshabilitar)
   * - Respeta MAX_RETRY_ATTEMPTS
   * - Usa jitter para evitar thundering herd
   */
  scheduleRetry() {
    // üö´ Verificaciones de seguridad
    if (!this.shouldReconnect) {
      Logger.debug(this.componentName, 'üö´ Reconexi√≥n deshabilitada por usuario');
      return;
    }
    
    if (this.retryCount >= WS_CONFIG.MAX_RETRY_ATTEMPTS) {
      Logger.error(this.componentName, `üö´ M√°ximo de reintentos alcanzado (${WS_CONFIG.MAX_RETRY_ATTEMPTS})`);
      return;
    }

    // üìà Incrementar contador e calcular delay
    this.retryCount++;
    const delay = this.calculateRetryDelay(this.retryCount);
    
    Logger.debug(this.componentName, `‚è∞ Programando reintento ${this.retryCount}/${WS_CONFIG.MAX_RETRY_ATTEMPTS} en ${delay}ms`);
    
    // ‚è≤Ô∏è Programar el reintento
    this.retryTimer = setTimeout(() => {
      Logger.debug(this.componentName, `üîÑ Ejecutando reintento ${this.retryCount}...`);
      this.attemptConnection(true);   // true = es reintento
    }, delay);
  }

  /**
   * üíì Sistema de Heartbeat
   * 
   * Los heartbeats son pings peri√≥dicos que enviamos al servidor para:
   * 1. Detectar conexiones "zombi" (aparentan estar vivas pero no funcionan)
   * 2. Mantener viva la conexi√≥n a trav√©s de firewalls/proxies
   * 3. Detectar problemas de red antes de que el usuario intente enviar datos
   * 
   * üì° FUNCIONAMIENTO:
   * - Cada 30 segundos enviamos {"type": "ping"}
   * - El servidor deber√≠a responder con {"type": "pong"}
   * - Si el env√≠o falla, la conexi√≥n est√° rota
   * 
   * üí° TIP: Si ves muchos errores de heartbeat, verifica:
   * - Configuraci√≥n de timeout en tu firewall/proxy
   * - Que el backend maneje mensajes de ping correctamente
   * - La estabilidad de la conexi√≥n de red
   */
  startHeartbeat() {
    // üßπ Limpiar heartbeat anterior si existe
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
    
    Logger.debug(this.componentName, `üíì Iniciando heartbeat cada ${WS_CONFIG.HEARTBEAT_INTERVAL}ms`);
    
    this.heartbeatTimer = setInterval(() => {
      // ‚úÖ Solo enviar si la conexi√≥n est√° realmente abierta
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        try {
          const pingMessage = JSON.stringify({ type: 'ping', timestamp: Date.now() });
          this.ws.send(pingMessage);
          Logger.debug(this.componentName, 'üíì Heartbeat enviado');
        } catch (error) {
          // ‚ö†Ô∏è Si el ping falla, la conexi√≥n probablemente est√° rota
          Logger.warn(this.componentName, 'üíî Error enviando heartbeat - conexi√≥n posiblemente rota:', error);
          // No forzamos cierre aqu√≠ - dejamos que el sistema lo detecte naturalmente
        }
      } else {
        // üö´ WebSocket no est√° abierto - detener heartbeat
        Logger.debug(this.componentName, 'üíî Deteniendo heartbeat: WebSocket no est√° abierto');
        this.clearTimers();
      }
    }, WS_CONFIG.HEARTBEAT_INTERVAL);
  }

  /**
   * üì§ Env√≠o de Mensajes
   * 
   * M√©todo seguro para enviar datos a trav√©s del WebSocket.
   * Incluye validaci√≥n de estado y manejo de errores.
   * 
   * üí° USO T√çPICO:
   * ```javascript
   * // Enviar objeto JSON
   * wsManager.send({ type: 'chat_message', content: 'Hola!' });
   * 
   * // Enviar string directo
   * wsManager.send('mensaje simple');
   * ```
   * 
   * üõ°Ô∏è VALIDACIONES:
   * - Verifica que WebSocket existe y est√° abierto
   * - Convierte objetos a JSON autom√°ticamente
   * - Captura errores de serializaci√≥n y env√≠o
   * - Devuelve booleano indicando √©xito/fallo
   * 
   * @param {string|Object} data - Datos a enviar (string o objeto serializable)
   * @returns {boolean} - true si se envi√≥ exitosamente, false en caso contrario
   */
  send(data) {
    // ‚úÖ Verificar que tenemos una conexi√≥n v√°lida
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      Logger.warn(this.componentName, 'üö´ No se puede enviar mensaje: WebSocket no conectado');
      Logger.debug(this.componentName, `Estado actual: ${this.ws ? this.ws.readyState : 'null'}`);
      return false;
    }

    try {
      // üîÑ Serializaci√≥n autom√°tica: objeto ‚Üí JSON string
      const message = typeof data === 'string' ? data : JSON.stringify(data);
      
      // üì§ Env√≠o real del mensaje
      this.ws.send(message);
      
      // üìù Log truncado para no saturar consola con mensajes largos
      const preview = message.substring(0, 100);
      Logger.debug(this.componentName, `üì§ Mensaje enviado: ${preview}${message.length > 100 ? '...' : ''}`);
      
      return true;
    } catch (error) {
      // üí• Capturar errores de serializaci√≥n JSON o env√≠o
      Logger.error(this.componentName, 'üí• Error enviando mensaje:', error);
      Logger.debug(this.componentName, 'Datos que causaron error:', data);
      return false;
    }
  }

  /**
   * üö™ Desconexi√≥n Manual
   * 
   * Cierra la conexi√≥n WebSocket de manera controlada y deshabilita
   * la reconexi√≥n autom√°tica. Usar cuando el usuario se desconecta
   * intencionalmente o cuando la aplicaci√≥n se cierra.
   * 
   * üîß PAR√ÅMETROS:
   * - code: C√≥digo de cierre est√°ndar (1000 = normal)
   * - reason: Texto descriptivo para logs y debugging
   * 
   * @param {number} code - C√≥digo de cierre WebSocket (por defecto: 1000 = normal)
   * @param {string} reason - Raz√≥n descriptiva de la desconexi√≥n
   */
  disconnect(code = WS_CONFIG.CLOSE_CODES.NORMAL, reason = 'Desconexi√≥n solicitada') {
    Logger.debug(this.componentName, `üö™ Desconectando WebSocket: ${reason} (c√≥digo: ${code})`);
    
    // üö´ Deshabilitar reconexi√≥n autom√°tica - esto es una desconexi√≥n intencional
    this.shouldReconnect = false;
    
    // üßπ Limpiar todos los recursos (timers, listeners, etc.)
    this.cleanup();
    
    // üîå Cerrar conexi√≥n si est√° abierta
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.close(code, reason);
    }
    
    // üìä Actualizar estado
    this.connectionState = WS_CONFIG.CONNECTION_STATES.DISCONNECTED;
  }

  /**
   * üßπ Limpieza de Timers
   * 
   * Cancela todos los timers activos para evitar memory leaks y
   * operaciones fantasma despu√©s de que se cierre la conexi√≥n.
   * 
   * ‚è∞ TIMERS QUE LIMPIAMOS:
   * - retryTimer: Timer de reconexi√≥n autom√°tica
   * - heartbeatTimer: Timer de pings peri√≥dicos
   * - connectionTimeout: Timer de timeout de conexi√≥n inicial
   * 
   * üí° IMPORTANTE: Siempre llamar este m√©todo antes de crear
   * una nueva conexi√≥n o al cerrar la aplicaci√≥n.
   */
  clearTimers() {
    // üîÑ Cancelar timer de reintentos
    if (this.retryTimer) {
      clearTimeout(this.retryTimer);
      this.retryTimer = null;
      Logger.debug(this.componentName, '‚è∞ Timer de reintento cancelado');
    }
    
    // üíì Cancelar timer de heartbeat
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
      Logger.debug(this.componentName, 'üíì Timer de heartbeat cancelado');
    }
    
    // ‚è∞ Cancelar timeout de conexi√≥n inicial
    if (this.connectionTimeout) {
      clearTimeout(this.connectionTimeout);
      this.connectionTimeout = null;
      Logger.debug(this.componentName, '‚è∞ Timeout de conexi√≥n cancelado');
    }
  }

  /**
   * üßπ Limpieza Completa de Recursos
   * 
   * M√©todo maestro que limpia TODOS los recursos del WebSocketManager.
   * Cancela timers, elimina listeners, y resetea referencias para
   * evitar memory leaks y comportamientos inesperados.
   * 
   * üîß QU√â LIMPIA:
   * - Todos los timers (retry, heartbeat, connection timeout)
   * - Event listeners del WebSocket
   * - Referencias al objeto WebSocket
   * 
   * üí° USO: Llamar antes de crear nueva conexi√≥n o al destruir el manager
   */
  cleanup() {
    Logger.debug(this.componentName, 'üßπ Iniciando limpieza completa de recursos...');
    
    // ‚è∞ Limpiar todos los timers
    this.clearTimers();
    
    // üîó Limpiar event listeners para evitar memory leaks
    if (this.ws) {
      this.ws.onopen = null;
      this.ws.onmessage = null;
      this.ws.onclose = null;
      this.ws.onerror = null;
      
      Logger.debug(this.componentName, 'üîó Event listeners removidos del WebSocket');
    }
    
    Logger.debug(this.componentName, '‚úÖ Limpieza completa finalizada');
  }

  /**
   * üìä Obtener Estado Actual
   * 
   * Devuelve el estado actual de la conexi√≥n. √ötil para mostrar
   * indicadores de estado en la UI (conectado/desconectado/reconectando).
   * 
   * üîÑ ESTADOS POSIBLES:
   * - 'connecting': Estableciendo conexi√≥n inicial
   * - 'connected': Conectado y funcional
   * - 'disconnected': Sin conexi√≥n
   * - 'reconnecting': Reintentando conexi√≥n autom√°ticamente
   * - 'failed': Error fatal, reconexi√≥n fall√≥ m√∫ltiples veces
   * 
   * @returns {string} Estado actual de la conexi√≥n
   */
  getConnectionState() {
    return this.connectionState;
  }

  /**
   * ‚úÖ Verificar Si Est√° Conectado
   * 
   * M√©todo de conveniencia que verifica si el WebSocket est√°
   * realmente abierto y listo para enviar/recibir datos.
   * 
   * üí° USA ESTO ANTES DE ENVIAR DATOS CR√çTICOS:
   * ```javascript
   * if (wsManager.isConnected()) {
   *   wsManager.send({ type: 'important_message', data: '...' });
   * } else {
   *   console.log('Esperando conexi√≥n...');
   * }
   * ```
   * 
   * @returns {boolean} true si est√° conectado y listo, false en caso contrario
   */
  isConnected() {
    return this.ws && this.ws.readyState === WebSocket.OPEN;
  }

  /**
   * üîÑ Reinicio Completo de Conexi√≥n
   * 
   * Fuerza un reinicio completo de la conexi√≥n WebSocket.
   * √ötil cuando detectas problemas y quieres "empezar de cero".
   * 
   * üîÑ PROCESO DE REINICIO:
   * 1. Desconecta la conexi√≥n actual (si existe)
   * 2. Resetea contadores de retry
   * 3. Habilita reconexi√≥n autom√°tica
   * 4. Intenta nueva conexi√≥n despu√©s de 1 segundo
   * 
   * üí° USO T√çPICO:
   * - Cuando la conexi√≥n est√° "trabada"
   * - Despu√©s de cambios de red (WiFi ‚Üí m√≥vil)
   * - Como √∫ltima opci√≥n cuando otros m√©todos fallan
   */
  restart() {
    Logger.debug(this.componentName, 'üîÑ Iniciando reinicio completo de conexi√≥n WebSocket...');
    
    // üö™ Desconectar conexi√≥n actual
    this.disconnect();
    
    // ‚è≥ Esperar un poco antes de reconectar para dar tiempo a la limpieza
    setTimeout(() => {
      Logger.debug(this.componentName, 'üöÄ Ejecutando reconexi√≥n despu√©s de reinicio...');
      
      // üîÑ Resetear estado para empezar de cero
      this.retryCount = 0;
      this.shouldReconnect = true;
      
      // üéØ Intentar nueva conexi√≥n
      this.attemptConnection();
    }, 1000);
  }
}

// üì§ EXPORTACI√ìN POR DEFECTO
// Exportamos la clase WebSocketManager como export default para facilitar su importaci√≥n:
// import WebSocketManager from './websocket-manager';

export default WebSocketManager;
